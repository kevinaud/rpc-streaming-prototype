# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: proposal/v1/proposal.proto, proposal/v1/proposal_service.proto, proposal/v1/session.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
  TYPE_CHECKING,
  AsyncIterator,
  Dict,
  Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

if TYPE_CHECKING:
  import grpclib.server
  from betterproto.grpc.grpclib_client import MetadataLike
  from grpclib.metadata import Deadline


class ProposalStatus(betterproto.Enum):
  """Status of a proposal."""

  UNSPECIFIED = 0
  """Default unspecified value."""

  PENDING = 1
  """Proposal is pending review."""

  APPROVED = 2
  """Proposal has been approved."""

  REJECTED = 3
  """Proposal has been rejected."""


@dataclass(eq=False, repr=False)
class Proposal(betterproto.Message):
  """A proposal submitted by an agent for approval."""

  proposal_id: str = betterproto.string_field(1)
  """Unique identifier for this proposal."""

  text: str = betterproto.string_field(2)
  """The text content of the proposal."""

  status: "ProposalStatus" = betterproto.enum_field(3)
  """Current status of the proposal."""

  created_at: datetime = betterproto.message_field(4)
  """Timestamp when the proposal was created."""


@dataclass(eq=False, repr=False)
class Session(betterproto.Message):
  """A shared session between an agent and a human reviewer."""

  session_id: str = betterproto.string_field(1)
  """Unique identifier for this session."""


@dataclass(eq=False, repr=False)
class SessionEvent(betterproto.Message):
  """An event that occurred within a session, streamed to subscribers."""

  proposal_created: "Proposal" = betterproto.message_field(1, group="event")
  """A new proposal was created."""

  proposal_updated: "Proposal" = betterproto.message_field(2, group="event")
  """An existing proposal was updated."""


@dataclass(eq=False, repr=False)
class CreateSessionRequest(betterproto.Message):
  """Request to create a new session."""

  pass


@dataclass(eq=False, repr=False)
class CreateSessionResponse(betterproto.Message):
  """Response containing the created session."""

  session: "Session" = betterproto.message_field(1)
  """The newly created session."""


@dataclass(eq=False, repr=False)
class GetSessionRequest(betterproto.Message):
  """Request to get a session by ID."""

  session_id: str = betterproto.string_field(1)
  """The session ID to retrieve."""


@dataclass(eq=False, repr=False)
class GetSessionResponse(betterproto.Message):
  """Response containing the requested session."""

  session: "Session" = betterproto.message_field(1)
  """The requested session."""


@dataclass(eq=False, repr=False)
class SubscribeRequest(betterproto.Message):
  """Request to subscribe to session events."""

  session_id: str = betterproto.string_field(1)
  """The session ID to subscribe to."""

  client_id: str = betterproto.string_field(2)
  """The client ID for this subscriber."""


@dataclass(eq=False, repr=False)
class SubscribeResponse(betterproto.Message):
  """Response containing a session event."""

  event: "SessionEvent" = betterproto.message_field(1)
  """The session event."""


@dataclass(eq=False, repr=False)
class SubmitProposalRequest(betterproto.Message):
  """Request to submit a new proposal."""

  session_id: str = betterproto.string_field(1)
  """The session ID to submit the proposal to."""

  text: str = betterproto.string_field(2)
  """The text content of the proposal."""


@dataclass(eq=False, repr=False)
class SubmitProposalResponse(betterproto.Message):
  """Response containing the created proposal."""

  proposal: "Proposal" = betterproto.message_field(1)
  """The created proposal."""


@dataclass(eq=False, repr=False)
class SubmitDecisionRequest(betterproto.Message):
  """Request to submit a decision on a proposal."""

  session_id: str = betterproto.string_field(1)
  """The session ID containing the proposal."""

  proposal_id: str = betterproto.string_field(2)
  """The proposal ID to decide on."""

  approved: bool = betterproto.bool_field(3)
  """Whether to approve (true) or reject (false)."""


@dataclass(eq=False, repr=False)
class SubmitDecisionResponse(betterproto.Message):
  """Response containing the updated proposal."""

  proposal: "Proposal" = betterproto.message_field(1)
  """The updated proposal."""


class ProposalServiceStub(betterproto.ServiceStub):
  async def create_session(
    self,
    create_session_request: "CreateSessionRequest",
    *,
    timeout: Optional[float] = None,
    deadline: Optional["Deadline"] = None,
    metadata: Optional["MetadataLike"] = None,
  ) -> "CreateSessionResponse":
    return await self._unary_unary(
      "/proposal.v1.ProposalService/CreateSession",
      create_session_request,
      CreateSessionResponse,
      timeout=timeout,
      deadline=deadline,
      metadata=metadata,
    )

  async def get_session(
    self,
    get_session_request: "GetSessionRequest",
    *,
    timeout: Optional[float] = None,
    deadline: Optional["Deadline"] = None,
    metadata: Optional["MetadataLike"] = None,
  ) -> "GetSessionResponse":
    return await self._unary_unary(
      "/proposal.v1.ProposalService/GetSession",
      get_session_request,
      GetSessionResponse,
      timeout=timeout,
      deadline=deadline,
      metadata=metadata,
    )

  async def subscribe(
    self,
    subscribe_request: "SubscribeRequest",
    *,
    timeout: Optional[float] = None,
    deadline: Optional["Deadline"] = None,
    metadata: Optional["MetadataLike"] = None,
  ) -> AsyncIterator[SubscribeResponse]:
    async for response in self._unary_stream(
      "/proposal.v1.ProposalService/Subscribe",
      subscribe_request,
      SubscribeResponse,
      timeout=timeout,
      deadline=deadline,
      metadata=metadata,
    ):
      yield response

  async def submit_proposal(
    self,
    submit_proposal_request: "SubmitProposalRequest",
    *,
    timeout: Optional[float] = None,
    deadline: Optional["Deadline"] = None,
    metadata: Optional["MetadataLike"] = None,
  ) -> "SubmitProposalResponse":
    return await self._unary_unary(
      "/proposal.v1.ProposalService/SubmitProposal",
      submit_proposal_request,
      SubmitProposalResponse,
      timeout=timeout,
      deadline=deadline,
      metadata=metadata,
    )

  async def submit_decision(
    self,
    submit_decision_request: "SubmitDecisionRequest",
    *,
    timeout: Optional[float] = None,
    deadline: Optional["Deadline"] = None,
    metadata: Optional["MetadataLike"] = None,
  ) -> "SubmitDecisionResponse":
    return await self._unary_unary(
      "/proposal.v1.ProposalService/SubmitDecision",
      submit_decision_request,
      SubmitDecisionResponse,
      timeout=timeout,
      deadline=deadline,
      metadata=metadata,
    )


class ProposalServiceBase(ServiceBase):
  async def create_session(
    self, create_session_request: "CreateSessionRequest"
  ) -> "CreateSessionResponse":
    raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

  async def get_session(
    self, get_session_request: "GetSessionRequest"
  ) -> "GetSessionResponse":
    raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

  async def subscribe(
    self, subscribe_request: "SubscribeRequest"
  ) -> AsyncIterator[SubscribeResponse]:
    raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
    yield SubscribeResponse()

  async def submit_proposal(
    self, submit_proposal_request: "SubmitProposalRequest"
  ) -> "SubmitProposalResponse":
    raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

  async def submit_decision(
    self, submit_decision_request: "SubmitDecisionRequest"
  ) -> "SubmitDecisionResponse":
    raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

  async def __rpc_create_session(
    self,
    stream: "grpclib.server.Stream[CreateSessionRequest, CreateSessionResponse]",
  ) -> None:
    request = await stream.recv_message()
    response = await self.create_session(request)
    await stream.send_message(response)

  async def __rpc_get_session(
    self, stream: "grpclib.server.Stream[GetSessionRequest, GetSessionResponse]"
  ) -> None:
    request = await stream.recv_message()
    response = await self.get_session(request)
    await stream.send_message(response)

  async def __rpc_subscribe(
    self, stream: "grpclib.server.Stream[SubscribeRequest, SubscribeResponse]"
  ) -> None:
    request = await stream.recv_message()
    await self._call_rpc_handler_server_stream(
      self.subscribe,
      stream,
      request,
    )

  async def __rpc_submit_proposal(
    self,
    stream: "grpclib.server.Stream[SubmitProposalRequest, SubmitProposalResponse]",
  ) -> None:
    request = await stream.recv_message()
    response = await self.submit_proposal(request)
    await stream.send_message(response)

  async def __rpc_submit_decision(
    self,
    stream: "grpclib.server.Stream[SubmitDecisionRequest, SubmitDecisionResponse]",
  ) -> None:
    request = await stream.recv_message()
    response = await self.submit_decision(request)
    await stream.send_message(response)

  def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
    return {
      "/proposal.v1.ProposalService/CreateSession": grpclib.const.Handler(
        self.__rpc_create_session,
        grpclib.const.Cardinality.UNARY_UNARY,
        CreateSessionRequest,
        CreateSessionResponse,
      ),
      "/proposal.v1.ProposalService/GetSession": grpclib.const.Handler(
        self.__rpc_get_session,
        grpclib.const.Cardinality.UNARY_UNARY,
        GetSessionRequest,
        GetSessionResponse,
      ),
      "/proposal.v1.ProposalService/Subscribe": grpclib.const.Handler(
        self.__rpc_subscribe,
        grpclib.const.Cardinality.UNARY_STREAM,
        SubscribeRequest,
        SubscribeResponse,
      ),
      "/proposal.v1.ProposalService/SubmitProposal": grpclib.const.Handler(
        self.__rpc_submit_proposal,
        grpclib.const.Cardinality.UNARY_UNARY,
        SubmitProposalRequest,
        SubmitProposalResponse,
      ),
      "/proposal.v1.ProposalService/SubmitDecision": grpclib.const.Handler(
        self.__rpc_submit_decision,
        grpclib.const.Cardinality.UNARY_UNARY,
        SubmitDecisionRequest,
        SubmitDecisionResponse,
      ),
    }
